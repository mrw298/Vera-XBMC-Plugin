<?xml version="1.0"?>
<implementation>
  <functions>
  	local ipAddress
	local json_http_port
	local json_tcp_port
	local ping_interval
	local serviceid = "urn:upnp-org:serviceId:XBMC1"
	local deviceid = lul_device
		
	local DEBUG_MODE = true
	
	local DEFAULT_XBMC_TCP_PORT = 9090
	local DEFAULT_XBMC_HTTP_PORT = 80
	local DEFAULT_PING_TIME = 180
	
	
	local function log(stuff, level)
		luup.log("XBMC: " .. stuff, (level or 50))
	end
	
	local function debug(stuff)
		if (DEBUG_MODE) then
			log("debug " .. stuff, 1)
		end
	end
  
  	-- From the NEST plugin
	local function readVariableOrInit(lul_device, serviceId, name, defaultValue) 
      local var = luup.variable_get(serviceId, name, lul_device)
      if (var == nil) then
        var = defaultValue
        luup.variable_set(serviceId, name, var, lul_device)
		log("Initialized variable: '" .. name .. "' = '" .. var .. "' SID is " .. serviceId )
      end
      return var
    end
	
	-- From the NEST plugin
	local function writeVariable(lul_device, serviceId, name, value) 
      luup.variable_set(serviceId, name, value, lul_device)
    end
	
	-- Originally from the NEST plugin
	local function writeVariableIfChanged(lul_device, serviceId, name, value)
      local curValue = luup.variable_get(serviceId, name, lul_device)
	  
	  -- convert to strings as numeric comparison of floats was hit
	  -- and miss to say the least
	  
      if (tostring(value) ~= tostring(curValue)) then
        writeVariable(lul_device, serviceId, name, value)
		log("Changed variable: '" .. name .. "' = '" .. value .. "' SID is " .. serviceId )
        return true
      else
        return false
      end
    end
	
 	function curlcall (meth, para)
		--debug("CURLCALL: port: " .. json_http_port .. " meth: " ..meth .. " para: " ..para .. " ip: " ..ipAddress)
		
		curlcommand = "curl -i -X POST -d '{\"jsonrpc\": \"4.0\", \"method\": \"" .. meth .. "\", \"params\": {" .. para .. "}, \"id\": 1}' http://" .. ipAddress .. ":" .. json_http_port .. "/jsonrpc"
		debug("CURLCALL COMMAND: " .. curlcommand)
		
		curlresponse = os.execute(curlcommand)
		debug("CURLCALL ANSWER: " .. curlresponse)
	end

	function XBMCall (action)

		--LEFT
		if (action == "left") then
		method = "Input.Left"
		params = ""
	
		--RIGHT
		elseif (action == "right") then
		method = "Input.Right"
		params = ""

		--UP
		elseif (action == "up") then
		method = "Input.Up"
		params = ""

		--DOWN
		elseif (action == "down") then
		method = "Input.Down"
		params = ""

		--BACK
		elseif (action == "back") then
		method = "Input.Back"
		params = ""

		--HOME
		elseif (action == "home") then
		method = "Input.Home"
		params = ""

		--ENTER
		elseif (action == "enter") then
		method = "Input.Select"
		params = ""

		--PLAY / PAUSE
		elseif (action == "playpause") then
		method = "Player.PlayPause"
		params = "\"playerid\": 1"

		--STOP
		elseif (action == "stop") then
		method = "Player.Stop"
		params = "\"playerid\": 1"

		--MUTE
		elseif (action == "mute") then
		method = "Application.SetMute"
		params = "\"mute\": \"toggle\""
		
		--REBOOT
		elseif (action == "reboot") then
		method = "System.Reboot"
		params = ""
		
		--SUSPEND
		elseif (action == "suspend") then
		method = "System.Suspend"
		params = ""
		
		--SHUTDOWN
		elseif (action == "shutdown") then
		method = "System.Shutdown"
		params = ""
		
		--AUDIO LIBRARY UPDATE
		elseif (action == "audioupdate") then
		method = "AudioLibrary.Scan"
		params = ""
		
		--AUDIO LIBRARY CLEAN
		elseif (action == "audioclean") then
		method = "AudioLibrary.Clean"
		params = ""
		
		--VIDEO LIBRARY SCAN
		elseif (action == "videoupdate") then
		method = "VideoLibrary.Scan"
		params = ""
		
		--VIDEO LIBRARY CLEAN
		elseif (action == "videoclean") then
		method = "VideoLibrary.Clean"
		params = ""
		
		--NEXT
		elseif (action == "next") then
		method = "Player.GoNext"
		params = "\"playerid\": 1"
		
		--PREVIOUS
		elseif (action == "prev") then
		method = "Player.GoPrevious"
		params = "\"playerid\": 1"
		
		--FASTER
		elseif (action == "faster") then
		method = "Player.SetSpeed"
		params = "\"playerid\": 1, \"speed\":\"increment\""
		
		--SLOWER
		elseif (action == "slower") then
		method = "Player.SetSpeed"
		params = "\"playerid\": 1, \"speed\":\"decrement\""
		
		--VOLUME UP
		elseif (action == "vup") then
		method = "Application.SetVolume"
		params = "\"volume\":100"
		
		--VOLUME DOWN
		elseif (action == "vdown") then
		method = "Application.SetVolume"
		params = "\"volume\":0"

		--ERROR
		else
		debug("XBMCall Command not found! action: " .. action)
		
		end

		debug("action: " .. action .. " method: " ..method .. " params: " ..params)
		
		curlcall (method, params)

	end
	

	function sendCommand(command)
		if (luup.io.write(command) == false) then
			log("Cannot send command " .. command .. " communications error")
			luup.set_failure(true)
			return false
		end
		return true
	end
	
	local function nextchar(result)
		return coroutine.yield(result)
	end

	local function JSONRPC_Process_Coroutine(ch)
		while true do
			local result
			if ( '{' == ch ) then
					local open_braces_found = 1
					result = ch
					while true do
						next_ch = nextchar()

						result = result .. next_ch

						if (next_ch == "{") then open_braces_found = open_braces_found + 1 end
						if (next_ch == "}") then open_braces_found = open_braces_found - 1 end

						if ( open_braces_found &lt;= 0 ) then break end

					end
			end

			if ( result ~= nil) then debug( "result: " .. result ) end
			ch = nextchar(result)
		end
	end

	local JSONRPC_Process = coroutine.wrap(JSONRPC_Process_Coroutine)
	
	function xbmc_ping()
		
		local ping_cmd ="{\"jsonrpc\": \"2.0\", \"method\": \"JSONRPC.Ping\", \"id\": 1}"
		local result = sendCommand(ping_cmd)
		
		return result
	end
	
	function getPlayerStatus()
		return luup.variable_get(serviceid, "PlayerStatus", lul_device)
	end
	
	function setPlayerStatus(status)
		return luup.variable_set(serviceid,"PlayerStatus", status, lul_device)
	end
	
	-- regular ping
	function scheduled_ping()
		log("sending routine ping")
	
		local result = xbmc_ping()
		if (result == true) then
			luup.variable_set(serviceid,"PingStatus","up",lul_device)
			debug("XBMCRemote is UP!")
		else
			luup.variable_set(serviceid,"PingStatus","down",lul_device)
			setPlayerStatus("--")
			luup.variable_set(serviceid,"IdleTime","--",lul_device)
			debug("XBMCRemote is DOWN!")
		end
		
		luup.call_timer("scheduled_ping", 1, ping_interval, "", "")
	end
	
	local function XBMC_processIncomingMessage(msg)
		
	end

	
		-- processed byte by byte
	local function XBMC_processIncoming(s)
		if (luup.is_ready(PARENT_DEVICE) == false) then
			return
		end
	
		local msg = JSONRPC_Process( s )

		if ( msg ~= nil ) then			
			debug( "MSG received: " .. msg )
			XBMC_processIncomingMessage(msg)
		end
	end

	 
	function init(lul_device)
		ipAddress = luup.devices[lul_device].ip
		
		json_tcp_port = readVariableOrInit(lul_device, serviceid, "XBMC_TCP_port", DEFAULT_XBMC_TCP_PORT)
		json_http_port = readVariableOrInit(lul_device, serviceid, "XBMC_HTTP_port", DEFAULT_XBMC_HTTP_PORT)		
		ping_interval = readVariableOrInit(lul_device, serviceid, "PingInterval", DEFAULT_PING_TIME)

		log("starting device: " .. tostring(lul_device))

		
		if (ipAddress == nil or ipAddress == "") then
			return false, "IP Address is required in Device's Advanced Settings!", "XBMCRemote"
		else
			local PingStatus1 = readVariableOrInit( lul_device, serviceid, "PingStatus", "--")
			local IdleTime1 = readVariableOrInit( lul_device, serviceid, "IdleTime", "--")
			local PlayerStatus1 = readVariableOrInit( lul_device, serviceid, "PlayerStatus", "--")
		end
		
		if (ipAddress ~= "") and (json_tcp_port ~= "") then
			log("Connecting to XBMC host on: " .. ipAddress .. ":" .. json_tcp_port )
			luup.io.open(PARENT_DEVICE, ipAddress, json_tcp_port)
		else
			return false,'No IP supplied, please enter the IP.','XBMC'
		end
		
		if luup.io.intercept()==false then
			log("Cannot connect. Confirm the IP address is correct.")
			return false,'Cannot connect. Confirm the IP address is correct.','XBMC'
		end
		
		luup.call_timer("scheduled_ping", 1, ping_interval, "", "")
		
		log("startup complete: " .. tostring(lul_device))
		
		return true,'ok','XBMC'
	end
  </functions>
  <startup>init</startup>
    <incoming>
    <lua>
        XBMC_processIncoming(tostring(lul_data))
    </lua>
  </incoming>
  <actionList>
    <action>
      <serviceId>urn:upnp-org:serviceId:XBMC1</serviceId>
      <name>GetPlayerStatus</name>
      <run>
        getPlayerStatus()
      </run>
    </action>
    <action>
      <serviceId>urn:upnp-org:serviceId:XBMC1</serviceId>
      <name>SetPlayerStatus</name>
      <run>
        setPlayerStatus(lul_settings.newPlayerStatus)
      </run>
    </action>
	<action>
      <serviceId>urn:upnp-org:serviceId:XBMC1</serviceId>
      <name>XBMCall</name>
      <run>
        XBMCall(lul_settings.action)
      </run>
    </action>
	
   </actionList>
</implementation>
 
 
